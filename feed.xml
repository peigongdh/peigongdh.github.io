<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>沛公的小站</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2022-09-19T18:25:26+08:00</updated> <author> <name>peigong</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 peigong </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>go向关闭的channel发送数据bug修复</title><link href="/posts/send-on-closed-channel/" rel="alternate" type="text/html" title="go向关闭的channel发送数据bug修复" /><published>2022-08-15T00:00:00+08:00</published> <updated>2022-09-16T17:31:40+08:00</updated> <id>/posts/send-on-closed-channel/</id> <content src="/posts/send-on-closed-channel/" /> <author> <name>peigong</name> </author> <category term="cs" /> <summary> 背景 遇到一个bug，程序偶发报错panic：send on closed channel 经过定位，可以发现协程刚好在向channel写数据时关闭 还原场景 package main import ( "fmt" "time" ) func main() { work() &amp;lt;-time.After(2000 * time.Millisecond) } func work() { fmt.Println("[work] start") resultChan := make(chan int) // 打开该注释以重现panic // defer close(resultChan) stopChan := make(chan interface{}, 1) defer close(stopChan) go func() { fmt... </summary> </entry> <entry><title>使用vscode的正则表达式提取文本</title><link href="/posts/vscode-pickup/" rel="alternate" type="text/html" title="使用vscode的正则表达式提取文本" /><published>2022-05-04T00:00:00+08:00</published> <updated>2022-05-04T00:00:00+08:00</updated> <id>/posts/vscode-pickup/</id> <content src="/posts/vscode-pickup/" /> <author> <name>peigong</name> </author> <category term="tool" /> <summary> 背景 工作中遇到需要从日志中提取用户uid，并做去重，如何使用vscode快速实现 解决方案 提取日志，按换行符分隔，每行一条日志，例如： Info 2022-04-01 00:06:00.748+08:00 uid = 'asdasdafsss' and condition_a = '1' Cost:2.03ms Info 2022-04-02 00:05:00.748+08:00 uid = 'asdasdasdfa' and condition_a = '1' Cost:2.03ms Info 2022-04-03 00:04:00.748+08:00 uid = 'safafsfasxx' and condition_a = '1' Cost:2.03ms Info 2022-04-04 00:03:00.748+08:00 uid = 'uufghfhgfhf' a... </summary> </entry> <entry><title>go string指针</title><link href="/posts/string-pointer/" rel="alternate" type="text/html" title="go string指针" /><published>2022-01-21T00:00:00+08:00</published> <updated>2022-01-21T14:14:58+08:00</updated> <id>/posts/string-pointer/</id> <content src="/posts/string-pointer/" /> <author> <name>peigong</name> </author> <category term="cs" /> <summary> 背景 最近开发中观察到业务中使用了大量的string指针，感觉极其别扭 之前对go中string的理解是类似于c++的vector这样的容器，已经在内部封装了string header的引用 不考虑二级指针的场景，笔者认为没有必要再次对string使用引用来节省空间，这里做了一些验证 实验 package main import ( "reflect" "unsafe" "github.com/davecgh/go-spew/spew" ) func xx(s string) { sh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s)) spew.Dump(sh) } func xx1(s string) { sh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;am... </summary> </entry> <entry><title>git实践 笔记</title><link href="/posts/git-practice-note/" rel="alternate" type="text/html" title="git实践 笔记" /><published>2022-01-11T00:00:00+08:00</published> <updated>2022-01-11T00:00:00+08:00</updated> <id>/posts/git-practice-note/</id> <content src="/posts/git-practice-note/" /> <author> <name>peigong</name> </author> <category term="cs" /> <summary> rebase 之前rebase用的不多，现在新的代码规范要求在自己的分支上rebase主干后再提交commit 重新梳理了一遍rebase的含义，其关键可以从字面理解，re-base，base就是我们checkout的那个commit mine : -&amp;gt; D -&amp;gt; E master : A -&amp;gt; B -&amp;gt; C -&amp;gt; F 当我们完成自己的开发想把自己的分支合并上去的时候，此时主干上已经有了新提交 如果我们不希望使用merge使主干变得杂乱，就用rebase将原来commit的基点从C变为F，即变基 mine : -&amp;gt; D -&amp;gt; E master : A -&amp;gt; B -&amp;gt; C -&amp;gt; F 虽然这样历史提交的真实过程被篡改了，但是如果只是在自己的分支上使用... </summary> </entry> <entry><title>跨源资源共享 笔记</title><link href="/posts/cors-note/" rel="alternate" type="text/html" title="跨源资源共享 笔记" /><published>2021-12-29T00:00:00+08:00</published> <updated>2021-12-29T15:28:43+08:00</updated> <id>/posts/cors-note/</id> <content src="/posts/cors-note/" /> <author> <name>peigong</name> </author> <category term="cs" /> <category term="web" /> <summary> 背景 日常在开发过程中经常遇到CORS相关的错误，解决方案也一直比较模糊，这次一起来把跨域相关的内容做一次梳理 Q：什么是跨域？ A：跨源HTTP请求的一个例子：运行在 https://domain-a.com 的 JavaScript 代码使用 XMLHttpRequest 来发起一个到 https://domain-b.com/data.json 的请求。 Q：为什么要做跨域的限制？ A：出于安全性，浏览器限制脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest 和 Fetch API 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源。 A：补充：考虑某个钓鱼网站A抓包模拟了网站B的API，A伪装B，误导用户在A中填写B的表单（例如账号密码），如果没有跨域... </summary> </entry> </feed>
