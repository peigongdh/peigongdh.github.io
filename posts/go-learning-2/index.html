<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="go语言 笔记2" /><meta property="og:locale" content="en" /><meta name="description" content="《快学 Go 语言》第 6 课 —— 字典" /><meta property="og:description" content="《快学 Go 语言》第 6 课 —— 字典" /><link rel="canonical" href="/posts/go-learning-2/" /><meta property="og:url" content="/posts/go-learning-2/" /><meta property="og:site_name" content="沛公的小站" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-06-08T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="go语言 笔记2" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-09-27T14:50:23+08:00","datePublished":"2021-06-08T00:00:00+08:00","description":"《快学 Go 语言》第 6 课 —— 字典","headline":"go语言 笔记2","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/go-learning-2/"},"url":"/posts/go-learning-2/"}</script><title>go语言 笔记2 | 沛公的小站</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="沛公的小站"><meta name="application-name" content="沛公的小站"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/7733966" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">沛公的小站</a></div><div class="site-subtitle font-italic">沛公写字的地方</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/peigongdh" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['peigong.dh','qq.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>go语言 笔记2</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>go语言 笔记2</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> peigong </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Jun 8, 2021, 12:00 AM +0800" >Jun 8, 2021<i class="unloaded">2021-06-08T00:00:00+08:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Sep 27, 2021, 2:50 PM +0800" >Sep 27, 2021<i class="unloaded">2021-09-27T14:50:23+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7955 words">44 min read</span></div></div><div class="post-content"><h2 id="快学-go-语言第-6-课--字典">《快学 Go 语言》第 6 课 —— 字典</h2><blockquote><p>https://zhuanlan.zhihu.com/p/50047198</p></blockquote><blockquote><p>如果你可以预知字典内部键值对的数量，那么还可以给 make 函数传递一个整数值，通知运行时提前分配好相应的内存。这样可以避免字典在长大的过程中要经历的多次扩容操作。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">var</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="m">16</span><span class="p">)</span>
</pre></table></code></div></div><blockquote><p>同 Python 语言一样，字典可以使用中括号来读写内部元素，使用 delete 函数来删除元素。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">fruits</span> <span class="o">=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span>
        <span class="s">"apple"</span><span class="o">:</span> <span class="m">2</span><span class="p">,</span>
        <span class="s">"banana"</span><span class="o">:</span> <span class="m">5</span><span class="p">,</span>
        <span class="s">"orange"</span><span class="o">:</span> <span class="m">8</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c">// 读取元素</span>
    <span class="k">var</span> <span class="n">score</span> <span class="o">=</span> <span class="n">fruits</span><span class="p">[</span><span class="s">"banana"</span><span class="p">]</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

    <span class="c">// 增加或修改元素</span>
    <span class="n">fruits</span><span class="p">[</span><span class="s">"pear"</span><span class="p">]</span> <span class="o">=</span> <span class="m">3</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">fruits</span><span class="p">)</span>

    <span class="c">// 删除元素</span>
    <span class="nb">delete</span><span class="p">(</span><span class="n">fruits</span><span class="p">,</span> <span class="s">"pear"</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">fruits</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// -----------------------</span>
<span class="c">// 5</span>
<span class="c">// map[apple:2 banana:5 orange:8 pear:3]</span>
<span class="c">// map[orange:8 apple:2 banana:5]</span>
</pre></table></code></div></div><blockquote><p><strong>删除操作时，如果对应的 key 不存在，delete 函数会静默处理。遗憾的是 delete 函数没有返回值，你无法直接得到 delete 操作是否真的删除了某个元素。你需要通过长度信息或者提前尝试读取 key 对应的 value 来得知。</strong></p></blockquote><blockquote><p>读操作时，如果 key 不存在，也不会抛出异常。它会返回 value 类型对应的零值。如果是字符串，对应的零值是空串，如果是整数，对应的零值是 0，如果是布尔型，对应的零值是 false。</p></blockquote><blockquote><p><strong>你不能通过返回的结果是否是零值来判断对应的 key 是否存在，因为 key 对应的 value 值可能恰好就是零值，比如下面的字典你就不能判断 “durin” 是否存在</strong></p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">fruits</span> <span class="o">=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">{</span>
        <span class="s">"apple"</span><span class="o">:</span> <span class="m">2</span><span class="p">,</span>
        <span class="s">"banana"</span><span class="o">:</span> <span class="m">5</span><span class="p">,</span>
        <span class="s">"orange"</span><span class="o">:</span> <span class="m">8</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c">// var names = make([]string, 0, len(fruits))</span>
    <span class="c">// var scores = make([]int, 0, len(fruits))</span>

    <span class="k">var</span> <span class="n">names</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fruits</span><span class="p">))</span>
    <span class="k">var</span> <span class="n">scores</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fruits</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">score</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">fruits</span> <span class="p">{</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">scores</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// ----------</span>
<span class="c">// [apple banana orange] [0 0 0 2 5 8]</span>
</pre></table></code></div></div><ul><li>这里需要留意如果使用这样的方式获取keys，那么会在[0 0 0]的基础上append<div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">var</span> <span class="n">names</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fruits</span><span class="p">))</span>
</pre></table></code></div></div></ul><h2 id="快学-go-语言第-7-课--字符串">《快学 Go 语言》第 7 课 —— 字符串</h2><blockquote><p>https://zhuanlan.zhihu.com/p/50399072</p></blockquote><blockquote><p><strong>字符串通常有两种设计，一种是「字符」串，一种是「字节」串。「字符」串中的每个字都是定长的，而「字节」串中每个字是不定长的。Go 语言里的字符串是「字节」串，英文字符占用 1 个字节，非英文字符占多个字节。这意味着无法通过位置来快速定位出一个完整的字符来，而必须通过遍历的方式来逐个获取单个字符。</strong></p></blockquote><blockquote><p>我们所说的字符通常是指 unicode 字符，你可以认为所有的英文和汉字在 unicode 字符集中都有一个唯一的整数编号，一个 unicode 通常用 4 个字节来表示，对应的 Go 语言中的字符 rune 占 4 个字节。在 Go 语言的源码中可以找到下面这行代码，rune 类型是一个衍生类型，它在内存里面使用 int32 类型的 4 个字节存储。</p></blockquote><blockquote><blockquote><p>type rune int32</p></blockquote></blockquote><blockquote><p>使用「字符」串来表示字符串势必会浪费空间，因为所有的英文字符本来只需要 1 个字节来表示，用 rune 字符来表示的话那么剩余的 3 个字节都是零。但是「字符」串有一个好处，那就是可以快速定位。</p></blockquote><blockquote><p>其中 codepoint 是每个「字」的其实偏移量。Go 语言的字符串采用 utf8 编码，中文汉字通常需要占用 3 个字节，英文只需要 1 个字节。len() 函数得到的是字节的数量，通过下标来访问字符串得到的是「字节」。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"嘻哈china"</span>
    <span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%x "</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c">// -----------</span>
<span class="c">// e5 98 bb e5 93 88 63 68 69 6e 61</span>
</pre></table></code></div></div><blockquote><p>按字符 rune 遍历</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"嘻哈china"</span>
    <span class="k">for</span> <span class="n">codepoint</span><span class="p">,</span> <span class="n">runeValue</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d %d "</span><span class="p">,</span> <span class="n">codepoint</span><span class="p">,</span> <span class="kt">int32</span><span class="p">(</span><span class="n">runeValue</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// -----------</span>
<span class="c">// 0 22075 3 21704 6 99 7 104 8 105 9 110 10 97</span>
</pre></table></code></div></div><blockquote><p>对字符串进行 range 遍历，每次迭代出两个变量 codepoint 和 runeValue。codepoint 表示字符起始位置，runeValue 表示对应的 unicode 编码（类型是 rune）。</p></blockquote><blockquote><p>在使用 Go 语言进行网络编程时，经常需要将来自网络的字节流转换成内存字符串，同时也需要将内存字符串转换成网络字节流。Go 语言直接内置了字节切片和字符串的相互转换语法。</p></blockquote><h2 id="快学-go-语言第-8-课--结构体">《快学 Go 语言》第 8 课 —— 结构体</h2><blockquote><p>https://zhuanlan.zhihu.com/p/50654803</p></blockquote><blockquote><p>Circle 结构体内部有三个变量，分别是圆心的坐标以及半径。特别需要注意是结构体内部变量的大小写，首字母大写是公开变量，首字母小写是内部变量，分别相当于类成员变量的 Public 和 Private 类别。内部变量只有属于同一个 package（简单理解就是同一个目录）的代码才能直接访问。</p></blockquote><blockquote><p>结构体的第二种创建形式是不指定字段名称来顺序字段初始化，需要显示提供所有字段的初值，一个都不能少。这种形式称之为「顺序形式」。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">Circle</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">x</span> <span class="kt">int</span>
    <span class="n">y</span> <span class="kt">int</span>
    <span class="n">Radius</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">c</span> <span class="n">Circle</span> <span class="o">=</span> <span class="n">Circle</span> <span class="p">{</span><span class="m">100</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="m">50</span><span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// -------</span>
<span class="c">// {x:100 y:100 Radius:50}</span>
</pre></table></code></div></div><blockquote><p>最后我们再将三种零值初始化形式放到一起对比观察一下</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">var</span> <span class="n">c1</span> <span class="n">Circle</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">{}</span>
<span class="k">var</span> <span class="n">c2</span> <span class="n">Circle</span>
<span class="k">var</span> <span class="n">c3</span> <span class="o">*</span><span class="n">Circle</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">Circle</span><span class="p">)</span>
</pre></table></code></div></div><blockquote><p>nil 结构体是指结构体指针变量没有指向一个实际存在的内存。这样的指针变量只会占用 1 个指针的存储空间，也就是一个机器字的内存大小。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">var</span> <span class="n">c</span> <span class="o">*</span><span class="n">Circle</span> <span class="o">=</span> <span class="no">nil</span>
</pre></table></code></div></div><blockquote><p>结构体的拷贝</p></blockquote><blockquote><p>结构体之间可以相互赋值，它在本质上是一次浅拷贝操作，拷贝了结构体内部的所有字段。结构体指针之间也可以相互赋值，它在本质上也是一次浅拷贝操作，不过它拷贝的仅仅是指针地址值，结构体的内容是共享的。</p></blockquote><blockquote><p>Go 语言的结构体方法里面没有 self 和 this 这样的关键字来指代当前的对象，它是用户自己定义的变量名称，通常我们都使用单个字母来表示。</p></blockquote><blockquote><p><strong>结构体的指针方法</strong></p></blockquote><blockquote><p>如果使用上面的方法形式给 Circle 增加一个扩大半径的方法，你会发现半径扩大不了。 这是因为上面的方法和前面的 expandByValue 函数是等价的，只不过是把函数的第一个参数挪了位置而已，参数传递时会复制了一份结构体内容，起不到扩大半径的效果。这时候就必须要使用结构体的指针方法</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="n">Circle</span><span class="p">)</span> <span class="n">expand</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">c</span><span class="o">.</span><span class="n">Radius</span> <span class="o">*=</span> <span class="m">2</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Circle</span><span class="p">)</span> <span class="n">expand</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">c</span><span class="o">.</span><span class="n">Radius</span> <span class="o">*=</span> <span class="m">2</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>结构体指针方法和值方法在调用时形式上是没有区别的，只不过一个可以改变结构体内部状态，而另一个不会。指针方法使用结构体值变量可以调用，值方法使用结构体指针变量也可以调用。</p></blockquote><blockquote><p><strong>匿名内嵌结构体</strong></p></blockquote><blockquote><p>还有一种特殊的内嵌结构体形式，内嵌的结构体不提供名称。这时外面的结构体将直接继承内嵌结构体所有的内部字段和方法，就好像把子结构体的一切全部都揉进了父结构体一样。匿名的结构体字段将会自动获得以结构体类型的名字命名的字段名称</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">Point</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">x</span> <span class="kt">int</span>
    <span class="n">y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="n">Point</span><span class="p">)</span> <span class="n">show</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Circle</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Point</span> <span class="c">// 匿名内嵌结构体</span>
    <span class="n">Radius</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span> <span class="p">{</span>
        <span class="n">Point</span><span class="o">:</span> <span class="n">Point</span> <span class="p">{</span>
            <span class="n">x</span><span class="o">:</span> <span class="m">100</span><span class="p">,</span>
            <span class="n">y</span><span class="o">:</span> <span class="m">100</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Radius</span><span class="o">:</span> <span class="m">50</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">Point</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="c">// 继承了字段</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">Point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">Point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c">// 继承了方法</span>
    <span class="n">c</span><span class="o">.</span><span class="n">Point</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// -------</span>
<span class="c">// {Point:{x:100 y:100} Radius:50}</span>
<span class="c">// {x:100 y:100}</span>
<span class="c">// 100 100</span>
<span class="c">// 100 100</span>
<span class="c">// 100 100</span>
<span class="c">// 100 100</span>
</pre></table></code></div></div><blockquote><p>这里的继承仅仅是形式上的语法糖，c.show() 被转换成二进制代码后和 c.Point.show() 是等价的，c.x 和 c.Point.x 也是等价的。</p></blockquote><blockquote><p>Go 语言不是面向对象语言在于它的结构体不支持多态，它不能算是一个严格的面向对象语言。多态是指父类定义的方法可以调用子类实现的方法，不同的子类有不同的实现，从而给父类的方法带来了多样的不同行为。下面的例子呈现了 Java 类的多态性。</p></blockquote><h2 id="快学-go-语言第-9-课--接口">《快学 Go 语言》第 9 课 —— 接口</h2><blockquote><p>https://zhuanlan.zhihu.com/p/50942676</p></blockquote><blockquote><p><strong>空接口</strong></p></blockquote><blockquote><p>如果一个接口里面没有定义任何方法，那么它就是空接口，任意结构体都隐式地实现了空接口。</p></blockquote><blockquote><p><strong>Go 语言为了避免用户重复定义很多空接口，它自己内置了一个，这个空接口的名字特别奇怪，叫 interface{} ，初学者会非常不习惯。之所以这个类型名带上了大括号，那是在告诉用户括号里什么也没有。我始终认为这种名字很古怪，它让代码看起来有点丑陋。</strong></p></blockquote><blockquote><p>空接口里面没有方法，所以它也不具有任何能力，其作用相当于 Java 的 Object 类型，可以容纳任意对象，它是一个万能容器。比如一个字典的 key 是字符串，但是希望 value 可以容纳任意类型的对象，类似于 Java 语言的 Map 类型，这时候就可以使用空接口类型 interface{}。</p></blockquote><blockquote><p><strong>接口变量的本质</strong></p></blockquote><blockquote><p>在使用接口时，我们要将接口看成一个特殊的容器，这个容器只能容纳一个对象，只有实现了这个接口类型的对象才可以放进去。</p></blockquote><blockquote><p>接口变量作为变量来说它也是需要占据内存空间的，通过翻阅 Go 语言的源码可以发现，接口变量也是由结构体来定义的，这个结构体包含两个指针字段，一个字段指向被容纳的对象内存，另一个字段指向一个特殊的结构体 itab，这个特殊的结构体包含了接口的类型信息和被容纳对象的数据类型信息。</p></blockquote><blockquote><p>接口变量的赋值</p></blockquote><blockquote><p>变量赋值本质上是一次内存浅拷贝，切片的赋值是拷贝了切片头，字符串的赋值是拷贝了字符串的头部，而数组的赋值呢是直接拷贝整个数组。接口变量的赋值会不会不一样呢？接下来我们做一个实验</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">Rect</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Width</span> <span class="kt">int</span>
    <span class="n">Height</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">a</span> <span class="k">interface</span> <span class="p">{}</span>
    <span class="k">var</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">{</span><span class="m">50</span><span class="p">,</span> <span class="m">50</span><span class="p">}</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">r</span>

    <span class="k">var</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="p">(</span><span class="n">Rect</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">Width</span> <span class="o">=</span> <span class="m">100</span>
    <span class="n">r</span><span class="o">.</span><span class="n">Height</span> <span class="o">=</span> <span class="m">100</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// ------</span>
<span class="c">// {50 50}</span>
</pre></table></code></div></div><blockquote><p>指向指针的接口变量</p></blockquote><blockquote><p>如果将上面的例子改成指针，将接口变量指向结构体指针，那结果就不一样了</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">Rect</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Width</span> <span class="kt">int</span>
    <span class="n">Height</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">a</span> <span class="k">interface</span> <span class="p">{}</span>
    <span class="k">var</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">{</span><span class="m">50</span><span class="p">,</span> <span class="m">50</span><span class="p">}</span>
    <span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">r</span> <span class="c">// 指向了结构体指针</span>

    <span class="k">var</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">Rect</span><span class="p">)</span> <span class="c">// 转换成指针类型</span>
    <span class="n">r</span><span class="o">.</span><span class="n">Width</span> <span class="o">=</span> <span class="m">100</span>
    <span class="n">r</span><span class="o">.</span><span class="n">Height</span> <span class="o">=</span> <span class="m">100</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// -------</span>
<span class="c">// &amp;{100 100}</span>
</pre></table></code></div></div><blockquote><p>从输出结果中可以看出指针变量 rx 指向的内存和变量 r 的内存是同一份。因为在类型转换的过程中只发生了指针变量的内存复制，而指针变量指向的内存是共享的。</p></blockquote><h2 id="快学-go-语言第-10-课--错误与异常">《快学 Go 语言》第 10 课 —— 错误与异常</h2><blockquote><p>https://zhuanlan.zhihu.com/p/51164928</p></blockquote><blockquote><p>Go 语言规定凡是实现了错误接口的对象都是错误对象，这个错误接口只定义了一个方法。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">type</span> <span class="kt">error</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="快学-go-语言第-11-课--千军万马跑协程">《快学 Go 语言》第 11 课 —— 千军万马跑协程</h2><blockquote><p>https://zhuanlan.zhihu.com/p/51516757</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>
<span class="k">import</span> <span class="s">"time"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"run in main goroutine"</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="m">3</span>
    <span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"dead loop goroutine start"</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">{}</span>  <span class="c">// 死循环</span>
        <span class="p">}()</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"main goroutine running"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>通过调整上面代码中的变量 n 的值可以发现一个有趣的现象，当 n 值大于 3 时，主协程将没有机会得到运行，而如果 n 值为 3、2、1，主协程依然可以每秒输出一次。要解释这个现象就必须深入了解协程的运行原理</p></blockquote><ul><li>这里的n设定为cpu逻辑核心数</ul><blockquote><p><strong>操作系统对线程的调度是抢占式的，也就是说单个线程的死循环不会影响其它线程的执行，每个线程的连续运行受到时间片的限制。</strong></p></blockquote><blockquote><p><strong>Go 语言运行时对协程的调度并不是抢占式的。如果单个协程通过死循环霸占了线程的执行权，那这个线程就没有机会去运行其它协程了，你可以说这个线程假死了。不过一个进程内部往往有多个线程，假死了一个线程没事，全部假死了才会导致整个进程卡死。</strong></p></blockquote><h2 id="快学-go-语言第-12-课--通道">《快学 Go 语言》第 12 课 —— 通道</h2><blockquote><p>https://zhuanlan.zhihu.com/p/51710515</p></blockquote><blockquote><p>不同的并行协程之间交流的方式有两种，一种是通过共享变量，另一种是通过队列。Go 语言鼓励使用队列的形式来交流，它单独为协程之间的队列数据交流定制了特殊的语法 —— 通道。</p></blockquote><blockquote><p>通道是协程的输入和输出。作为协程的输出，通道是一个容器，它可以容纳数据。作为协程的输入，通道是一个生产者，它可以向协程提供数据。通道作为容器是有限定大小的，满了就写不进去，空了就读不出来。通道还有它自己的类型，它可以限定进入通道的数据的类型。</p></blockquote><blockquote><p>创建通道只有一种语法，那就是 make 全局函数，提供第一个类型参数限定通道可以容纳的数据类型，再提供第二个整数参数作为通道的容器大小。大小参数是可选的，如果不填，那这个通道的容量为零，叫着「非缓冲型通道」，非缓冲型通道必须确保有协程正在尝试读取当前通道，否则写操作就会阻塞直到有其它协程来从通道中读东西。非缓冲型通道总是处于既满又空的状态。与之对应的有限定大小的通道就是缓冲型通道。在 Go 语言里不存在无界通道，每个通道都是有限定最大容量的。</p></blockquote><blockquote><p>通道作为容器，它可以像切片一样，使用 cap() 和 len() 全局函数获得通道的容量和当前内部的元素个数。通道一般作为不同的协程交流的媒介，在同一个协程里它也是可以使用的。</p></blockquote><blockquote><p><strong>读写阻塞</strong></p></blockquote><blockquote><p><strong>通道满了，写操作就会阻塞，协程就会进入休眠，直到有其它协程读通道挪出了空间，协程才会被唤醒。如果有多个协程的写操作都阻塞了，一个读操作只会唤醒一个协程。</strong> <strong>通道空了，读操作就会阻塞，协程也会进入睡眠，直到有其它协程写通道装进了数据才会被唤醒。如果有多个协程的读操作阻塞了，一个写操作也只会唤醒一个协程。</strong></p></blockquote><blockquote><p><strong>关闭通道</strong></p></blockquote><blockquote><p><strong>Go 语言的通道有点像文件，不但支持读写操作， 还支持关闭。读取一个已经关闭的通道会立即返回通道类型的「零值」，而写一个已经关闭的通道会抛异常。如果通道里的元素是整型的，读操作是不能通过返回值来确定通道是否关闭的。</strong></p></blockquote><blockquote><p><strong>当通道空了，循环会暂停阻塞，当通道关闭时，阻塞停止，循环也跟着结束了。当循环结束时，我们就知道通道已经关闭了。</strong></p></blockquote><blockquote><p><strong>通道写安全</strong></p></blockquote><blockquote><p><strong>确保通道写安全的最好方式是由负责写通道的协程自己来关闭通道，读通道的协程不要去关闭通道。</strong></p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">send</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">1</span>
 <span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">2</span>
 <span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">3</span>
 <span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">4</span>
 <span class="nb">close</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">recv</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="k">var</span> <span class="n">ch</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
 <span class="k">go</span> <span class="n">send</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
 <span class="n">recv</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// -----------</span>
<span class="c">// 1</span>
<span class="c">// 2</span>
<span class="c">// 3</span>
<span class="c">// 4</span>
</pre></table></code></div></div><blockquote><p><strong>这个方法确实可以解决单写多读的场景，可要是遇上了多写单读的场合该怎么办呢？任意一个读写通道的协程都不可以随意关闭通道，否则会导致其它写通道协程抛出异常。这时候就必须让其它不相干的协程来干这件事，这个协程需要等待所有的写通道协程都结束运行后才能关闭通道。那其它协程要如何才能知道所有的写通道已经结束运行了呢？这个就需要使用到内置 sync 包提供的 WaitGroup 对象，它使用计数来等待指定事件完成。</strong></p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>
<span class="k">import</span> <span class="s">"time"</span>
<span class="k">import</span> <span class="s">"sync"</span>

<span class="k">func</span> <span class="n">send</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">wg</span> <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span> <span class="c">// 计数值减一</span>
 <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span>
 <span class="k">for</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">4</span> <span class="p">{</span>
  <span class="n">i</span><span class="o">++</span>
  <span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">i</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">recv</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="k">var</span> <span class="n">ch</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
 <span class="k">var</span> <span class="n">wg</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">)</span>
 <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">2</span><span class="p">)</span> <span class="c">// 增加计数值</span>
 <span class="k">go</span> <span class="n">send</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">wg</span><span class="p">)</span>  <span class="c">// 写</span>
 <span class="k">go</span> <span class="n">send</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">wg</span><span class="p">)</span>  <span class="c">// 写</span>
 <span class="k">go</span> <span class="n">recv</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
 <span class="c">// Wait() 阻塞等待所有的写通道协程结束</span>
 <span class="c">// 待计数值变成零，Wait() 才会返回</span>
 <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
 <span class="c">// 关闭通道</span>
 <span class="nb">close</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
 <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// ---------</span>
<span class="c">// 1</span>
<span class="c">// 2</span>
<span class="c">// 3</span>
<span class="c">// 4</span>
<span class="c">// 1</span>
<span class="c">// 2</span>
<span class="c">// 3</span>
<span class="c">// 4</span>
</pre></table></code></div></div><blockquote><p>多路通道</p></blockquote><blockquote><p>在真实的世界中，还有一种消息传递场景，那就是消费者有多个消费来源，只要有一个来源生产了数据，消费者就可以读这个数据进行消费。这时候可以将多个来源通道的数据汇聚到目标通道，然后统一在目标通道进行消费。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>
<span class="k">import</span> <span class="s">"time"</span>

<span class="c">// 每隔一会生产一个数</span>
<span class="k">func</span> <span class="n">send</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">gap</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span>
 <span class="k">for</span> <span class="p">{</span>
  <span class="n">i</span><span class="o">++</span>
  <span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">i</span>
  <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">gap</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="c">// 将多个原通道内容拷贝到单一的目标通道</span>
<span class="k">func</span> <span class="n">collect</span><span class="p">(</span><span class="n">source</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">target</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">source</span> <span class="p">{</span>
  <span class="n">target</span> <span class="o">&lt;-</span> <span class="n">v</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="c">// 从目标通道消费数据</span>
<span class="k">func</span> <span class="n">recv</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"receive %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>


<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="k">var</span> <span class="n">ch1</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
 <span class="k">var</span> <span class="n">ch2</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
 <span class="k">var</span> <span class="n">ch3</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
 <span class="k">go</span> <span class="n">send</span><span class="p">(</span><span class="n">ch1</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
 <span class="k">go</span> <span class="n">send</span><span class="p">(</span><span class="n">ch2</span><span class="p">,</span> <span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
 <span class="k">go</span> <span class="n">collect</span><span class="p">(</span><span class="n">ch1</span><span class="p">,</span> <span class="n">ch3</span><span class="p">)</span>
 <span class="k">go</span> <span class="n">collect</span><span class="p">(</span><span class="n">ch2</span><span class="p">,</span> <span class="n">ch3</span><span class="p">)</span>
 <span class="n">recv</span><span class="p">(</span><span class="n">ch3</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// ---------</span>
<span class="c">// receive 1</span>
<span class="c">// receive 1</span>
<span class="c">// receive 2</span>
<span class="c">// receive 2</span>
<span class="c">// receive 3</span>
<span class="c">// receive 4</span>
<span class="c">// receive 3</span>
<span class="c">// receive 5</span>
<span class="c">// receive 6</span>
<span class="c">// receive 4</span>
<span class="c">// receive 7</span>
<span class="c">// receive 8</span>
<span class="c">// receive 5</span>
<span class="c">// receive 9</span>
<span class="c">// ....</span>
</pre></table></code></div></div><blockquote><p>但是上面这种形式比较繁琐，需要为每一种消费来源都单独启动一个汇聚协程。Go 语言为这种使用场景带来了「多路复用」语法糖，也就是下面要讲的 select 语句，它可以同时管理多个通道读写，如果所有通道都不能读写，它就整体阻塞，只要有一个通道可以读写，它就会继续。下面我们使用 select 语句来简化上面的逻辑</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>
<span class="k">import</span> <span class="s">"time"</span>

<span class="k">func</span> <span class="n">send</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">gap</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span>
 <span class="k">for</span> <span class="p">{</span>
  <span class="n">i</span><span class="o">++</span>
  <span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">i</span>
  <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">gap</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">recv</span><span class="p">(</span><span class="n">ch1</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ch2</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">for</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">v</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="n">ch1</span><span class="o">:</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"recv %d from ch1</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
   <span class="k">case</span> <span class="n">v</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="n">ch2</span><span class="o">:</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"recv %d from ch2</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">}</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="k">var</span> <span class="n">ch1</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
 <span class="k">var</span> <span class="n">ch2</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
 <span class="k">go</span> <span class="n">send</span><span class="p">(</span><span class="n">ch1</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
 <span class="k">go</span> <span class="n">send</span><span class="p">(</span><span class="n">ch2</span><span class="p">,</span> <span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
 <span class="n">recv</span><span class="p">(</span><span class="n">ch1</span><span class="p">,</span> <span class="n">ch2</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// ------------</span>
<span class="c">// recv 1 from ch2</span>
<span class="c">// recv 1 from ch1</span>
<span class="c">// recv 2 from ch1</span>
<span class="c">// recv 3 from ch1</span>
<span class="c">// recv 2 from ch2</span>
<span class="c">// recv 4 from ch1</span>
<span class="c">// recv 3 from ch2</span>
<span class="c">// recv 5 from ch1</span>
</pre></table></code></div></div><blockquote><p>上面是多路复用 select 语句的读通道形式，下面是它的写通道形式，只要有一个通道能写进去，它就会打破阻塞。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">ch1</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="o">:</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"send to ch1"</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">ch2</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="o">:</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"send to ch2"</span><span class="p">)</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>前面我们讲的读写都是阻塞读写，Go 语言还提供了通道的非阻塞读写。当通道空时，读操作不会阻塞，当通道满时，写操作也不会阻塞。非阻塞读写需要依靠 select 语句的 default 分支。当 select 语句所有通道都不可读写时，如果定义了 default 分支，那就会执行 default 分支逻辑，这样就起到了不阻塞的效果。下面我们演示一个单生产者多消费者的场景。生产者同时向两个通道写数据，写不进去就丢弃。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>
<span class="k">import</span> <span class="s">"time"</span>

<span class="k">func</span> <span class="n">send</span><span class="p">(</span><span class="n">ch1</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ch2</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span>
 <span class="k">for</span> <span class="p">{</span>
  <span class="n">i</span><span class="o">++</span>
  <span class="k">select</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">ch1</span> <span class="o">&lt;-</span> <span class="n">i</span><span class="o">:</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"send ch1 %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
   <span class="k">case</span> <span class="n">ch2</span> <span class="o">&lt;-</span> <span class="n">i</span><span class="o">:</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"send ch2 %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
   <span class="k">default</span><span class="o">:</span>
  <span class="p">}</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">recv</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">gap</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">,</span> <span class="n">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"receive %s %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">gap</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="c">// 无缓冲通道</span>
 <span class="k">var</span> <span class="n">ch1</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
 <span class="k">var</span> <span class="n">ch2</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
 <span class="c">// 两个消费者的休眠时间不一样，名称不一样</span>
 <span class="k">go</span> <span class="n">recv</span><span class="p">(</span><span class="n">ch1</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">,</span> <span class="s">"ch1"</span><span class="p">)</span>
 <span class="k">go</span> <span class="n">recv</span><span class="p">(</span><span class="n">ch2</span><span class="p">,</span> <span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">,</span> <span class="s">"ch2"</span><span class="p">)</span>
 <span class="n">send</span><span class="p">(</span><span class="n">ch1</span><span class="p">,</span> <span class="n">ch2</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// ------------</span>
<span class="c">// send ch1 27</span>
<span class="c">// send ch2 28</span>
<span class="c">// receive ch1 27</span>
<span class="c">// receive ch2 28</span>
<span class="c">// send ch1 6708984</span>
<span class="c">// receive ch1 6708984</span>
<span class="c">// send ch2 13347544</span>
<span class="c">// send ch1 13347775</span>
<span class="c">// receive ch2 13347544</span>
<span class="c">// receive ch1 13347775</span>
<span class="c">// send ch1 20101642</span>
<span class="c">// receive ch1 20101642</span>
<span class="c">// send ch2 26775795</span>
<span class="c">// receive ch2 26775795</span>
<span class="c">// ...</span>
</pre></table></code></div></div><ul><li>注意此处，在非阻塞的channel中，往一个不带缓冲的队列中写入数据时可能会失败（数据被丢弃）</ul><blockquote><p>通道在其它语言里面的表现形式是队列，在 Java 语言里，带缓冲通道就是并发包内置的 java.util.concurrent.ArrayBlockingQueue，无缓冲通道也是并发包内置的 java.util.concurrent.SynchronousQueue。ArrayBlockingQueue 的内部实现形式是一个数组，多线程读写时需要使用锁来控制并发访问。不过像 Go 语言提供的多路复用效果，Java 语言就没有内置的实现了。</p></blockquote><blockquote><p>Go 语言的通道内部结构是一个循环数组，通过读写偏移量来控制元素发送和接受。它为了保证线程安全，内部会有一个全局锁来控制并发。对于发送和接受操作都会有一个队列来容纳处于阻塞状态的协程。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">type</span> <span class="n">hchan</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">qcount</span> <span class="kt">uint</span>  <span class="c">// 通道有效元素个数</span>
  <span class="n">dataqsize</span> <span class="kt">uint</span>   <span class="c">// 通道容量，循环数组总长度</span>
  <span class="n">buf</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="c">// 数组地址</span>
  <span class="n">elemsize</span> <span class="kt">uint16</span> <span class="c">// 内部元素的大小</span>
  <span class="n">closed</span> <span class="kt">uint32</span> <span class="c">// 是否已关闭 0或者1</span>
  <span class="n">elemtype</span> <span class="o">*</span><span class="n">_type</span> <span class="c">// 内部元素类型信息</span>
  <span class="n">sendx</span> <span class="kt">uint</span> <span class="c">// 循环数组的写偏移量</span>
  <span class="n">recvx</span> <span class="kt">uint</span> <span class="c">// 循环数组的读偏移量</span>
  <span class="n">recvq</span> <span class="n">waitq</span> <span class="c">// 阻塞在读操作上的协程队列</span>
  <span class="n">sendq</span> <span class="n">waitq</span> <span class="c">// 阻塞在写操作上的协程队列</span>
  
  <span class="n">lock</span> <span class="n">mutex</span> <span class="c">// 全局锁</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="快学-go-语言第-13-课--并发与安全">《快学 Go 语言》第 13 课 —— 并发与安全</h2><blockquote><p>https://zhuanlan.zhihu.com/p/52376005</p></blockquote><blockquote><p><strong>日常应用中，大多数并发数据结构都是读多写少的，对于读多写少的场合，可以将互斥锁换成读写锁，可以有效提升性能。sync 包也提供了读写锁对象 RWMutex，不同于互斥锁只有两个常用方法 Lock() 和 Unlock()，读写锁提供了四个常用方法，分别是写加锁 Lock()、写释放锁 Unlock()、读加锁 RLock() 和读释放锁 RUnlock()。写锁是排他锁，加写锁时会阻塞其它协程再加读锁和写锁，读锁是共享锁，加读锁还可以允许其它协程再加读锁，但是会阻塞加写锁。</strong></p></blockquote><blockquote><p>读写锁在写并发高的情况下性能退化为普通的互斥锁。</p></blockquote><h2 id="快学-go-语言第-14-课--魔术变性指针">《快学 Go 语言》第 14 课 —— 魔术变性指针</h2><blockquote><p>https://zhuanlan.zhihu.com/p/52756600</p></blockquote><blockquote><p>在 Go 语言里不同类型之间的转换是要受限的。普通的基础变量转换成不同的类型需要进行内存浅拷贝，而指针变量类型之间是禁止直接转换的。要打破这个限制，unsafe.Pointer 就可以派上用场，它允许任意指针类型的互转。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>
<span class="k">import</span> <span class="s">"unsafe"</span>

<span class="k">type</span> <span class="n">Rect</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Width</span> <span class="kt">int</span>
    <span class="n">Height</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Rect</span> <span class="p">{</span><span class="m">50</span><span class="p">,</span> <span class="m">50</span><span class="p">}</span>
    <span class="c">// var pw *int</span>
    <span class="k">var</span> <span class="n">pw</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">))</span>
    <span class="c">// var ph *int</span>
    <span class="k">var</span> <span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="kt">uintptr</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">))</span> <span class="o">+</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Offsetof</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">Height</span><span class="p">))</span>
    <span class="o">*</span><span class="n">pw</span> <span class="o">=</span> <span class="m">100</span>
    <span class="o">*</span><span class="n">ph</span> <span class="o">=</span> <span class="m">100</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">Width</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">Height</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// --------</span>
<span class="c">// 100 100</span>
</pre></table></code></div></div><blockquote><p>从上面 5 个 问题，我们可以得出结论，接口类型和结构体类型似乎是两个不同的世界。只有接口类型之间的赋值和转换会共享数据，其它情况都会复制数据，其它情况包括结构体之间的赋值，结构体转接口，接口转结构体。不同接口变量之间的转换本质上只是调整了接口变量内部的类型指针，数据指针并不会发生改变。</p></blockquote><h2 id="快学-go-语言第-15-课--反射">《快学 Go 语言》第 15 课 —— 反射</h2><blockquote><p>https://zhuanlan.zhihu.com/p/53114706</p></blockquote><blockquote><p>reflect.Kind，reflect 包定义了十几种内置的「元类型」，每一种元类型都有一个整数编号，这个编号使用 reflect.Kind 类型表示。不同的结构体是不同的类型，但是它们都是同一个元类型 Struct。包含不同子元素的切片也是不同的类型，但是它们都会同一个元类型 Slice。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">type</span> <span class="n">Kind</span> <span class="kt">uint</span>

<span class="k">const</span> <span class="p">(</span>
    <span class="n">Invalid</span> <span class="n">Kind</span> <span class="o">=</span> <span class="no">iota</span> <span class="c">// 不存在的无效类型</span>
    <span class="n">Bool</span>
    <span class="n">Int</span>
    <span class="n">Int8</span>
    <span class="n">Int16</span>
    <span class="n">Int32</span>
    <span class="n">Int64</span>
    <span class="n">Uint</span>
    <span class="n">Uint8</span>
    <span class="n">Uint16</span>
    <span class="n">Uint32</span>
    <span class="n">Uint64</span>
    <span class="n">Uintptr</span> <span class="c">// 指针的整数类型，对指针进行整数运算时使用</span>
    <span class="n">Float32</span>
    <span class="n">Float64</span>
    <span class="n">Complex64</span>
    <span class="n">Complex128</span>
    <span class="n">Array</span> <span class="c">// 数组类型</span>
    <span class="n">Chan</span> <span class="c">// 通道类型</span>
    <span class="n">Func</span>  <span class="c">// 函数类型</span>
    <span class="n">Interface</span>  <span class="c">// 接口类型</span>
    <span class="n">Map</span> <span class="c">// 字典类型</span>
    <span class="n">Ptr</span> <span class="c">// 指针类型</span>
    <span class="n">Slice</span> <span class="c">// 切片类型</span>
    <span class="n">String</span> <span class="c">// 字符串类型</span>
    <span class="n">Struct</span> <span class="c">// 结构体类型</span>
    <span class="n">UnsafePointer</span> <span class="c">// unsafe.Pointer 类型</span>
<span class="p">)</span>
</pre></table></code></div></div><blockquote><p>它是一个接口类型，里面定义了非常多的方法用于获取和这个类型相关的一切信息。这个接口的结构体实现隐藏在 reflect 包里，每一种类型都有一个相关的类型结构体来表达它的结构信息。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">type</span> <span class="n">Type</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="n">Method</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="n">Method</span>  <span class="c">// 获取挂在类型上的第 i'th 个方法</span>
  <span class="o">...</span>
  <span class="n">NumMethod</span><span class="p">()</span> <span class="kt">int</span>  <span class="c">// 该类型上总共挂了几个方法</span>
  <span class="n">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="c">// 类型的名称</span>
  <span class="n">PkgPath</span><span class="p">()</span> <span class="kt">string</span> <span class="c">// 所在包的名称</span>
  <span class="n">Size</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="c">// 占用字节数</span>
  <span class="n">String</span><span class="p">()</span> <span class="kt">string</span> <span class="c">// 该类型的字符串形式</span>
  <span class="n">Kind</span><span class="p">()</span> <span class="n">Kind</span> <span class="c">// 元类型</span>
  <span class="o">...</span>
  <span class="n">Bits</span><span class="p">()</span> <span class="c">// 占用多少位</span>
  <span class="n">ChanDir</span><span class="p">()</span> <span class="c">// 通道的方向</span>
  <span class="o">...</span>
  <span class="n">Elem</span><span class="p">()</span> <span class="n">Type</span> <span class="c">// 数组，切片，通道，指针，字典(key)的内部子元素类型</span>
  <span class="n">Field</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="n">StructField</span> <span class="c">// 获取结构体的第 i'th 个字段</span>
  <span class="o">...</span>
  <span class="n">In</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="n">Type</span>  <span class="c">// 获取函数第 i'th 个参数类型</span>
  <span class="n">Key</span><span class="p">()</span> <span class="n">Type</span> <span class="c">// 字典的 key 类型</span>
  <span class="n">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="c">// 数组的长度</span>
  <span class="n">NumIn</span><span class="p">()</span> <span class="kt">int</span> <span class="c">// 函数的参数个数</span>
  <span class="n">NumOut</span><span class="p">()</span> <span class="kt">int</span> <span class="c">// 函数的返回值个数</span>
  <span class="n">Out</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="n">Type</span> <span class="c">// 获取函数 第 i'th 个返回值类型</span>
  <span class="n">common</span><span class="p">()</span> <span class="o">*</span><span class="n">rtype</span> <span class="c">// 获取类型结构体的共同部分</span>
  <span class="n">uncommon</span><span class="p">()</span> <span class="o">*</span><span class="n">uncommonType</span> <span class="c">// 获取类型结构体的不同部分</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>所有的类型结构体都包含一个共同的部分信息，这部分信息使用 rtype 结构体描述，rtype 实现了 Type 接口的所有方法。剩下的不同的部分信息各种特殊类型结构体都不一样。可以将 rtype 理解成父类，特殊类型的结构体是子类，会有一些不一样的字段信息。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c">// 基础类型 rtype 实现了 Type 接口</span>
<span class="k">type</span> <span class="n">rtype</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">size</span> <span class="kt">uintptr</span> <span class="c">// 占用字节数</span>
  <span class="n">ptrdata</span> <span class="kt">uintptr</span>
  <span class="n">hash</span> <span class="kt">uint32</span> <span class="c">// 类型的hash值</span>
  <span class="o">...</span>
  <span class="n">kind</span> <span class="kt">uint8</span> <span class="c">// 元类型</span>
  <span class="o">...</span>
<span class="p">}</span>

<span class="c">// 切片类型</span>
<span class="k">type</span> <span class="n">sliceType</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">rtype</span>
  <span class="n">elem</span> <span class="o">*</span><span class="n">rtype</span> <span class="c">// 元素类型</span>
<span class="p">}</span>

<span class="c">// 结构体类型</span>
<span class="k">type</span> <span class="n">structType</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">rtype</span>
  <span class="n">pkgPath</span> <span class="n">name</span>  <span class="c">// 所在包名</span>
  <span class="n">fields</span> <span class="p">[]</span><span class="n">structField</span>  <span class="c">// 字段列表</span>
<span class="p">}</span>

<span class="o">...</span>
</pre></table></code></div></div><blockquote><p>不同于 reflect.Type 接口，reflect.Value 是结构体类型，一个非常简单的结构体。</p></blockquote><div class="language-go highlighter-rouge"><div class="code-header"> <span text-data=" Go "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">type</span> <span class="n">Value</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">typ</span> <span class="o">*</span><span class="n">rtype</span>  <span class="c">// 变量的类型结构体</span>
  <span class="n">ptr</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="c">// 数据指针</span>
  <span class="n">flag</span> <span class="kt">uintptr</span> <span class="c">// 标志位</span>
<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cs/'>cs</a>, <a href='/categories/go/'>go</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/go/" class="post-tag no-text-decoration" >go</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/gcache-note/">gcache源码阅读 笔记</a><li><a href="/posts/send-on-closed-channel/">go向关闭的channel发送数据bug修复</a><li><a href="/posts/string-pointer/">go string指针</a><li><a href="/posts/http-get-params-list/">http get列表参数 笔记</a><li><a href="/posts/cors-note/">跨源资源共享 笔记</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/nsq/">nsq</a> <a class="post-tag" href="/tags/stack/">stack</a> <a class="post-tag" href="/tags/tcp/">tcp</a> <a class="post-tag" href="/tags/file/">file</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/mq/">mq</a> <a class="post-tag" href="/tags/queue/">queue</a> <a class="post-tag" href="/tags/sort/">sort</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/go-learning-1/"><div class="card-body"> <span class="timeago small" >Jun 8, 2021<i class="unloaded">2021-06-08T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>go语言 笔记1</h3><div class="text-muted small"><p> 《快学 Go 语言》第 1 课 —— Hello World https://zhuanlan.zhihu.com/p/48013279 go不需要要设置goroot和gopath（默认~/go） 《快学 Go 语言》第 2 课 —— 变量基础 https://zhuanlan.zhihu.com/p/48153187 var s int = 42 var s ...</p></div></div></a></div><div class="card"> <a href="/posts/go-http-note-1/"><div class="card-body"> <span class="timeago small" >Sep 26, 2021<i class="unloaded">2021-09-26T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>http in go 笔记1</h3><div class="text-muted small"><p> http in go 从入口开始看 1 2 3 4 5 6 7 8 9 10 11 // ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted con...</p></div></div></a></div><div class="card"> <a href="/posts/go-http-note-2/"><div class="card-body"> <span class="timeago small" >Sep 26, 2021<i class="unloaded">2021-09-26T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>http in go 笔记2</h3><div class="text-muted small"><p> 问题 一个 TCP 连接可以发多少个 HTTP 请求 要搞懂这个问题，我们需要先解决下面五个问题： 0、现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？ 1、一个 TCP 连接可以对应几个 HTTP 请求？ 2、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？ 3、...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/go-learning-1/" class="btn btn-outline-primary" prompt="Older"><p>go语言 笔记1</p></a> <a href="/posts/chirpy-starter/" class="btn btn-outline-primary" prompt="Newer"><p>Chirpy Starter</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/peigongdh">peigong</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/nsq/">nsq</a> <a class="post-tag" href="/tags/stack/">stack</a> <a class="post-tag" href="/tags/tcp/">tcp</a> <a class="post-tag" href="/tags/file/">file</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/mq/">mq</a> <a class="post-tag" href="/tags/queue/">queue</a> <a class="post-tag" href="/tags/sort/">sort</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
