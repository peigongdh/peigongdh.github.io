<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="select/poll/epoll详解 笔记" /><meta property="og:locale" content="en" /><meta name="description" content="概念说明" /><meta property="og:description" content="概念说明" /><link rel="canonical" href="/posts/select-poll-epoll-note/" /><meta property="og:url" content="/posts/select-poll-epoll-note/" /><meta property="og:site_name" content="沛公的小站" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-09-26T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="select/poll/epoll详解 笔记" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-09-27T15:48:18+08:00","datePublished":"2021-09-26T00:00:00+08:00","description":"概念说明","headline":"select/poll/epoll详解 笔记","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/select-poll-epoll-note/"},"url":"/posts/select-poll-epoll-note/"}</script><title>select/poll/epoll详解 笔记 | 沛公的小站</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="沛公的小站"><meta name="application-name" content="沛公的小站"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/7733966" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">沛公的小站</a></div><div class="site-subtitle font-italic">沛公写字的地方</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/peigongdh" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['peigong.dh','qq.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>select/poll/epoll详解 笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>select/poll/epoll详解 笔记</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> peigong </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Sep 26, 2021, 12:00 AM +0800" >Sep 26, 2021<i class="unloaded">2021-09-26T00:00:00+08:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Sep 27, 2021, 3:48 PM +0800" >Sep 27, 2021<i class="unloaded">2021-09-27T15:48:18+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5793 words">32 min read</span></div></div><div class="post-content"><h2 id="概念说明">概念说明</h2><ul><li>用户空间和内核空间<li>进程切换<li>进程的阻塞<li>文件描述符<li>缓存 I/O</ul><h2 id="用户空间与内核空间">用户空间与内核空间</h2><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。 为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。 针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h2 id="进程切换">进程切换</h2><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。<li>更新PCB信息。<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<li>选择另一个进程执行，并更新其PCB。<li>更新内存管理的数据结构。<li>恢复处理机上下文。</ol><p>TODO: 从linux的角度理解PCB（task_struct）</p><h2 id="进程的阻塞">进程的阻塞</h2><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。 可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><h2 id="文件描述符fd">文件描述符fd</h2><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h2 id="缓存-io">缓存 I/O</h2><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。 在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p>缓存 I/O 的缺点： 数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h2 id="io模式">IO模式</h2><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p><ol><li>等待数据准备 (Waiting for the data to be ready)<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</ol><p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p><ul><li>阻塞 I/O（blocking IO）<li>非阻塞 I/O（nonblocking IO）<li>I/O 多路复用（ IO multiplexing）<li>信号驱动 I/O（ signal driven IO）<li>异步 I/O（asynchronous IO）</ul><p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p><h3 id="阻塞ioblocking-io">阻塞IO（blocking IO）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><p>所以，blocking IO的特点就是在IO执行的两个阶段（wait for data / copy data from kernel to user）都被block了。</p><h3 id="非阻塞-iononblocking-io">非阻塞 I/O（nonblocking IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p><h3 id="io-多路复用io-multiplexing">I/O 多路复用（IO multiplexing）</h3><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><h3 id="异步-ioasynchronous-io">异步 I/O（asynchronous IO）</h3><p>inux下的asynchronous IO其实用得很少。先看一下它的流程：</p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><h3 id="总结">总结</h3><h4 id="blocking和non-blocking的区别">blocking和non-blocking的区别</h4><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><h4 id="synchronous-io和asynchronous-io的区别">synchronous IO和asynchronous IO的区别</h4><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p><ul><li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</ul><p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p><p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p><p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><h2 id="io-多路复用之selectpollepoll详解">I/O 多路复用之select、poll、epoll详解</h2><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）</p><h2 id="select">SELECT</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">select</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</pre></table></code></div></div><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><h2 id="poll">POLL</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">poll</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pollfd</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span> <span class="cm">/* file descriptor */</span>
    <span class="kt">short</span> <span class="n">events</span><span class="p">;</span> <span class="cm">/* requested events to watch */</span>
    <span class="kt">short</span> <span class="n">revents</span><span class="p">;</span> <span class="cm">/* returned events witnessed */</span>
<span class="p">};</span>
</pre></table></code></div></div><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。 pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。 从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p><h2 id="epoll">EPOLL</h2><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><h3 id="操作过程">操作过程</h3><p>epoll操作过程需要三个接口，分别如下：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span><span class="err">；</span><span class="c1">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span>
<span class="kt">int</span> <span class="n">epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span><span class="err">；</span>
<span class="kt">int</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span> <span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
</pre></table></code></div></div><ol><li><p>int epoll_create(int size); 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。 当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； 函数是对指定描述符fd执行op操作。</p><ul><li>epfd：是epoll_create()的返回值。<li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。<li>fd：是需要监听的fd（文件描述符）<li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</ul></ol><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">epoll_event</span> <span class="p">{</span>
  <span class="n">__uint32_t</span> <span class="n">events</span><span class="p">;</span>  <span class="cm">/* Epoll events */</span>
  <span class="n">epoll_data_t</span> <span class="n">data</span><span class="p">;</span>  <span class="cm">/* User data variable */</span>
<span class="p">};</span>

<span class="c1">//events可以是以下几个宏的集合：</span>
<span class="n">EPOLLIN</span> <span class="err">：表示对应的文件描述符可以读（包括对端</span><span class="n">SOCKET</span><span class="err">正常关闭）；</span>
<span class="n">EPOLLOUT</span><span class="err">：表示对应的文件描述符可以写；</span>
<span class="n">EPOLLPRI</span><span class="err">：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span>
<span class="n">EPOLLERR</span><span class="err">：表示对应的文件描述符发生错误；</span>
<span class="n">EPOLLHUP</span><span class="err">：表示对应的文件描述符被挂断；</span>
<span class="n">EPOLLET</span><span class="err">：</span> <span class="err">将</span><span class="n">EPOLL</span><span class="err">设为边缘触发</span><span class="p">(</span><span class="n">Edge</span> <span class="n">Triggered</span><span class="p">)</span><span class="err">模式，这是相对于水平触发</span><span class="p">(</span><span class="n">Level</span> <span class="n">Triggered</span><span class="p">)</span><span class="err">来说的。</span>
<span class="n">EPOLLONESHOT</span><span class="err">：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个</span><span class="n">socket</span><span class="err">的话，需要再次把这个</span><span class="n">socket</span><span class="err">加入到</span><span class="n">EPOLL</span><span class="err">队列里</span>
</pre></table></code></div></div><ol><li>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 等待epfd上的io事件，最多返回maxevents个事件。 参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</ol><h3 id="工作模式">工作模式</h3><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下： 　　LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。 　　ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><ol><li><p>LT模式 LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p><li><p>ET模式 ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p></ol><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">while</span><span class="p">(</span><span class="n">rs</span><span class="p">){</span>
  <span class="n">buflen</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">activeevents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">buflen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span>
    <span class="c1">// 在这里就当作是该次事件已处理处.</span>
    <span class="k">if</span><span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">){</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">buflen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
     <span class="c1">// 这里表示对端的socket已正常关闭.</span>
  <span class="p">}</span>

 <span class="k">if</span><span class="p">(</span><span class="n">buflen</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">){</span>
      <span class="n">rs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// 需要再次读取</span>
 <span class="p">}</span>
 <span class="k">else</span><span class="p">{</span>
      <span class="n">rs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Linux中的EAGAIN含义</p><p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。 从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p><p>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。 又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p><h3 id="代码延时">代码延时</h3><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
</pre><td class="rouge-code"><pre><span class="cp">#define IPADDRESS   "127.0.0.1"
#define PORT        8787
#define MAXSIZE     1024
#define LISTENQ     5
#define FDSIZE      1000
#define EPOLLEVENTS 100
</span>
<span class="n">listenfd</span> <span class="o">=</span> <span class="n">socket_bind</span><span class="p">(</span><span class="n">IPADDRESS</span><span class="p">,</span><span class="n">PORT</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">events</span><span class="p">[</span><span class="n">EPOLLEVENTS</span><span class="p">];</span>

<span class="c1">//创建一个描述符</span>
<span class="n">epollfd</span> <span class="o">=</span> <span class="n">epoll_create</span><span class="p">(</span><span class="n">FDSIZE</span><span class="p">);</span>

<span class="c1">//添加监听描述符事件</span>
<span class="n">add_event</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">listenfd</span><span class="p">,</span><span class="n">EPOLLIN</span><span class="p">);</span>

<span class="c1">//循环等待</span>
<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">){</span>
    <span class="c1">//该函数返回已经准备好的描述符事件数目</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">events</span><span class="p">,</span><span class="n">EPOLLEVENTS</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">//处理接收到的连接</span>
    <span class="n">handle_events</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">events</span><span class="p">,</span><span class="n">ret</span><span class="p">,</span><span class="n">listenfd</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//事件处理函数</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_events</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span><span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span><span class="kt">int</span> <span class="n">num</span><span class="p">,</span><span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
     <span class="c1">//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span>
     <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="n">fd</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
        <span class="c1">//根据描述符的类型和事件类型进行处理</span>
         <span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">==</span> <span class="n">listenfd</span><span class="p">)</span> <span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">))</span>
            <span class="n">handle_accpet</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">listenfd</span><span class="p">);</span>
         <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span>
            <span class="n">do_read</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>
         <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">)</span>
            <span class="n">do_write</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>
     <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//添加事件</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_event</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="kt">int</span> <span class="n">state</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span><span class="p">;</span>
    <span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
    <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">EPOLL_CTL_ADD</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//处理接收到的连接</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_accpet</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">listenfd</span><span class="p">){</span>
     <span class="kt">int</span> <span class="n">clifd</span><span class="p">;</span>     
     <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">cliaddr</span><span class="p">;</span>     
     <span class="n">socklen_t</span>  <span class="n">cliaddrlen</span><span class="p">;</span>     
     <span class="n">clifd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cliaddrlen</span><span class="p">);</span>     
     <span class="k">if</span> <span class="p">(</span><span class="n">clifd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>         
     <span class="n">perror</span><span class="p">(</span><span class="s">"accpet error:"</span><span class="p">);</span>     
     <span class="k">else</span> <span class="p">{</span>         
         <span class="n">printf</span><span class="p">(</span><span class="s">"accept a new client: %s:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">inet_ntoa</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">),</span><span class="n">cliaddr</span><span class="p">.</span><span class="n">sin_port</span><span class="p">);</span>                       <span class="c1">//添加一个客户描述符和事件         </span>
         <span class="n">add_event</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">clifd</span><span class="p">,</span><span class="n">EPOLLIN</span><span class="p">);</span>     
     <span class="p">}</span> 
<span class="p">}</span>

<span class="c1">//读处理</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_read</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">nread</span><span class="p">;</span>
    <span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">MAXSIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>     <span class="p">{</span>         
        <span class="n">perror</span><span class="p">(</span><span class="s">"read error:"</span><span class="p">);</span>         
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span> <span class="c1">//记住close fd        </span>
        <span class="n">delete_event</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">EPOLLIN</span><span class="p">);</span> <span class="c1">//删除监听 </span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>     <span class="p">{</span>         
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"client close.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span> <span class="c1">//记住close fd       </span>
        <span class="n">delete_event</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">EPOLLIN</span><span class="p">);</span> <span class="c1">//删除监听 </span>
    <span class="p">}</span>     
    <span class="k">else</span> <span class="p">{</span>         
        <span class="n">printf</span><span class="p">(</span><span class="s">"read message is : %s"</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>        
        <span class="c1">//修改描述符对应的事件，由读改为写         </span>
        <span class="n">modify_event</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">EPOLLOUT</span><span class="p">);</span>     
    <span class="p">}</span> 
<span class="p">}</span>

<span class="c1">//写处理</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>     
    <span class="kt">int</span> <span class="n">nwrite</span><span class="p">;</span>     
    <span class="n">nwrite</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>     
    <span class="k">if</span> <span class="p">(</span><span class="n">nwrite</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>         
        <span class="n">perror</span><span class="p">(</span><span class="s">"write error:"</span><span class="p">);</span>        
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>   <span class="c1">//记住close fd       </span>
        <span class="n">delete_event</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">EPOLLOUT</span><span class="p">);</span>  <span class="c1">//删除监听    </span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="n">modify_event</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">EPOLLIN</span><span class="p">);</span> 
    <span class="p">}</span>    
    <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">MAXSIZE</span><span class="p">);</span> 
<span class="p">}</span>

<span class="c1">//删除事件</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_event</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="kt">int</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span><span class="p">;</span>
    <span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
    <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">EPOLL_CTL_DEL</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//修改事件</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">modify_event</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="kt">int</span> <span class="n">state</span><span class="p">){</span>     
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span><span class="p">;</span>
    <span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
    <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">EPOLL_CTL_MOD</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//注：另外一端我就省了</span>

</pre></table></code></div></div><h2 id="参考">参考</h2><blockquote><p>https://segmentfault.com/a/1190000003063859</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cs/'>cs</a>, <a href='/categories/os/'>os</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/select/" class="post-tag no-text-decoration" >select</a> <a href="/tags/poll/" class="post-tag no-text-decoration" >poll</a> <a href="/tags/epoll/" class="post-tag no-text-decoration" >epoll</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/gcache-note/">gcache源码阅读 笔记</a><li><a href="/posts/send-on-closed-channel/">go向关闭的channel发送数据bug修复</a><li><a href="/posts/string-pointer/">go string指针</a><li><a href="/posts/http-get-params-list/">http get列表参数 笔记</a><li><a href="/posts/cors-note/">跨源资源共享 笔记</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/nsq/">nsq</a> <a class="post-tag" href="/tags/stack/">stack</a> <a class="post-tag" href="/tags/tcp/">tcp</a> <a class="post-tag" href="/tags/file/">file</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/mq/">mq</a> <a class="post-tag" href="/tags/queue/">queue</a> <a class="post-tag" href="/tags/sort/">sort</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/epoll-note/"><div class="card-body"> <span class="timeago small" >Sep 25, 2021<i class="unloaded">2021-09-25T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>epoll 笔记</h3><div class="text-muted small"><p> 文件描述符 linux下的文件描述符是一个用于表述指向文件的引用的抽象化概念(在windows下是HANDLE句柄). 文件描述符在形式上是一个非负整数值.但实际上,他是一个索引值,指向系统内核为每个进程维护的一张记录表. 在这张记录表上记录每个进程打开的文件对应的文件结构体信息.　 那么也就是说,文件描述符不存在事件这一说法,文件描述符本身不会产生事件,但文件描述符对应...</p></div></div></a></div><div class="card"> <a href="/posts/file-descriptor-note/"><div class="card-body"> <span class="timeago small" >Sep 25, 2021<i class="unloaded">2021-09-25T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>文件描述符 笔记</h3><div class="text-muted small"><p> 获取文件描述符 从形式上来看文件描述就是一个整数，那么我们可不可以更进一步去了解一下呢？ 本文打算通过一步一步实验去了解文件描述符到底是什么， 并在最后通过Linux内核相关的源码进行验证。 int main(int argc, char* argv[]) { // 以只读模式打开 demo.txt 文件 int fd = open("demo.txt", O_RDONLY); i...</p></div></div></a></div><div class="card"> <a href="/posts/fork-exec-note/"><div class="card-body"> <span class="timeago small" >Sep 25, 2021<i class="unloaded">2021-09-25T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>fork-exec 笔记</h3><div class="text-muted small"><p> fork 使用fork完，会创建一个子进程，内部处理逻辑，是让这俩进程共享代码段，同时，会新复制数据段和堆栈段（这里实际上没有做复制操作，只有在写新数据的时候，才会往不同地方写） 调用完fork，返回pid，对于父进程而言，pid&gt;0，是子进程的pid。对于子进程而言，pid=0 调用完fork，对于父进程和子进程，会从下面一条语句开始执行。这里非常奇妙，相当于实时备份了一整个进程状...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/seckill-design/" class="btn btn-outline-primary" prompt="Older"><p>秒杀系统设计</p></a> <a href="/posts/tcp-congestion-control-note/" class="btn btn-outline-primary" prompt="Newer"><p>tcp拥塞控制 笔记</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/peigongdh">peigong</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/nsq/">nsq</a> <a class="post-tag" href="/tags/stack/">stack</a> <a class="post-tag" href="/tags/tcp/">tcp</a> <a class="post-tag" href="/tags/file/">file</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/mq/">mq</a> <a class="post-tag" href="/tags/queue/">queue</a> <a class="post-tag" href="/tags/sort/">sort</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
