---
layout: post
title:  "jwt 笔记"
date:   2021-09-26 00:00:00 +0800
categories: cs
tag: jwt
---

## 跨域认证的问题

互联网服务离不开用户认证。一般流程是下面这样。

- 1、用户向服务器发送用户名和密码。
- 2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。
- 3、服务器向用户返回一个 session_id，写入用户的 Cookie。
- 4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。
- 5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。

这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。
举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？
一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。
另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。

## JWT 的原理

JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。
{
  "姓名": "张三",
  "角色": "管理员",
  "到期时间": "2018年7月1日0点0分"
}
以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。
服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。

## 对比

实际应用中，JWT的缺陷较大  
一个JWT大概长这样：  
```
base64(header).base64(json payload).signature
```
header部分描述一些基本信息，比如这个token是用什么算法签名的，是什么版本的等等。  
payload就是一个json object。你可以任意放置你想要的信息，只要符合json的格式即可。标准中已经规定好了有一些字段的意思，比如iat表示issue at，token签发的时间；exp表示token过期的时间等等。根据这些约定就可以实现一些小的代码库来检查比如token是不是过期了等等。但是请注意，很多人误解，认为JWT是加了密的，但其实payload是明文的。  
signature是一个签名。服务器端可以自行选择一个算法和一个secret，与payload拼接上，得到一个签名。secret并不会在网络中传输，所以客户端无法伪造一个JWT。这样，一旦一个签名生成，再传回给服务器，服务器就可以知道这个token是不是它当初生成的。  
通过这样的机制，JWT中可以存储一些认证必要的信息。给定一个JWT，服务器只要验证：  
这个JWT的签名是对的  
这个JWT还在生效（即当前时间在JWT生效时刻之后，在失效时刻之前）  
之后服务器就可以信任这个JWT中包含的信息，包括user id、包含的权限等等。服务器不需要自己再去查询一遍这个用户的信息，以及这个用户的权限信息，就可以对请求作出相应。不用session了，无状态大法好！然而，需要泼一下冷水的是：  
  
使用了JWT，无法实现在服务器端对用户请求进行管理——管理员没法统计多少个人登录了，一个人登录了多少次，登陆了什么设备；同时，也无法强行“踢”掉一个用户的登录——JWT一旦生成，在失效之前，总是有效的。如果实现了一个token黑名单之类的功能，就等价于实现了Session机制，无状态带来的好处就无从谈起。这个限制对于任何一个要认真做用户风险控制的网站来说都是不可能接受的。  
使用了JWT，无法很好的控制payload的数据量。尽管规范表示，应该只把认证的相关信息放到payload里。但实际上，开发人员往往会误用，把几乎所有和user相关的数据都放到payload里。而payload的尺寸过大，比如达到数KB，就会极大的损耗带宽和IO性能。要记得，为了达成“无状态”，每个请求都必须把全量的JWT都带着……  
这两个严重的缺陷限定了JWT只能用到一些不太认真的场景。而对于真正的社交、金融、游戏等认真一点的服务，还是要选择基于Session的认证。  
  
当然，token中的签名还是有好处的，签名可以确保token的确是服务器产生的，不会被篡改。如果token中包含了user id，那么还可以实现简单的前端错误上报；如果token中还有session id，就可以在服务器端实现基于Session的认证。因此，你可以将user id、session id、token过期时间等几个关键数据放到payload里——只放这几个，不放其他的数据，得到一个用来做Session认证的JWT。更进一步，如果你把JWT的规范稍微小改一下，比如payload不用JSON，而是更紧凑的格式；定死了签名算法，即可省略JWT的header了；最后再优化一下编码格式，就能得到一个你自己的token。  
但，无论用session还是token，还是什么其他的名字，这些都不重要。重要的是服务器这边必须实现session机制，以便于对用户登录信息进行有效的管理。  

## 安全

### XSS

使用基于Token认证的开发人员很喜欢使用Header + Local Storage。因为这样可以有效防止CSRF （下一小节专门讲）。  
但是使用Local Storage，反而会增加中招XSS（Crossing Site Script）的机会。一旦中招XSS，攻击者可以轻易的拿到认证信息，并且传回自己的接受网址而不被用户察觉。这样一来攻击者能够轻易的代替用户登录了。  
整个浏览器中，只有一种资源是脚本无法访问到的。这就是被设置为HttpOnly的cookie。这是非常理想的放置认证token/session id的地方。设置这种token只需要在Set Cookie时这么写：  
> Set-Cookie: access_token=xxxxxxxxxxxxxxxxxx; HttpOnly; Secure; Same-Site=strict; Path=/;
(Secure和Same-Site是什么？下文会解释)
XSS攻击者没有任何办法从HttpOnly的Cookie中拿到你的认证信息，除非他能在你登录网站后，直接进入你的电脑，打开浏览器的开发者工具并人肉复制粘贴  

### CSRF

CSRF代表Crossing Site Recource Forge。大致的触发流程是：  

用户登录了站点A，并且在Cookie中留下了A站点的认证信息  
用户进入了站点B，而站点B用一些方式（比如一个提交行为是到A站点某关键接口的表单）引诱用户去点击。当用户点击时，会发出到A站点的请求。而浏览器会给这个请求附带上A站点的认证信息，从而让这个请求能够执行。这种行为可能是，但不限于，给某个A站点的某个其他用户提权/转账/发文辱骂等等。  
上文中提到了，很多人用JWT+Local Storage的本心是为了防护CRSF。这样做的原因是——因为Cookie的发送是完全由浏览器控制的，不受网页本身的控制。所以最简单直接的办法，就是不用Cookie，不让自动发送认证信息成为可能。问题在于，这么干是有XSS风险的。从上文中可以看到，为了避免XSS，就必须用HttpOnlyCookie。  

### XSS对比CSRF



## 参考

> http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html

> https://blog.nowcoder.net/n/7a6a4758eef4444ea7ea301640cb46db