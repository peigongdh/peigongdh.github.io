---
layout: post
title:  "fctnl 笔记"
date:   2021-09-25 00:00:00 +0800
categories: cs
tag: [file, fcntl]
---

## file control

fcntl函数有五种功能：
- 复制一个现存的描述符（cmd＝F_DUPFD）。
- 获得/设置文件描述符标记（cmd = F_GETFD或F_SETFD）。
- 获得/设置文件状态标志（cmd = F_GETFL或F_SETFL）。
- 获得/设置异步I/O有权（cmd = F_GETOW N或F_SETOWN）。
- 获得/设置记录锁（cmd = F_GETLK , F_SETL K或F_ SETLKW）

- F_DUPFD 复制文件描述符f i l e d e s，新文件描述符作为函数值返回。它是尚未打开的各
描述符中大于或等于第三个参数值（取为整型值）中各值的最小值。新描述符与 filedes共享同
一文件表项（见图3-3）。但是，新描述符有它自己的一套文件描述符标志，其 FD_CLOEXEC
文件描述符标志则被清除（这表示该描述符在 exec 时仍保持开放，我们将在第 8章对此进行
讨论）。
- F_GETFD 对应于filedes 的文件描述符标志作为函数值返回。当前只定义了一个文件描
述符标志FD_CLOEXEC。
- F_SETFD 对于filedes 设置文件描述符标志。新标志值按第三个参数(取为整型值)设置。
应当了解很多现存的涉及文件描述符标志的程序并不使用常数FD_CLOEXEC，而是将此
标志设置为0 (系统默认，在exec时不关闭)或1 (在exec时关闭)。
- F_GETFL 对应于filedes 的文件状态标志作为函数值返回。在说明open函数时，已说明
了文件状态标志。它们列于表3 - 2中。

## FD_CLOEXEC

我们经常会碰到需要fork子进程的情况，而且子进程很可能会继续exec新的程序。这就不得不提到子进程中无用文件描述符的问题！

fork函数的使用本不是这里讨论的话题，但必须提一下的是：子进程以写时复制（COW，Copy-On-Write）方式获得父进程的数据空间、堆和栈副本，这其中也包括文件描述符。刚刚fork成功时，父子进程中相同的文件描述符指向系统文件表中的同一项（这也意味着他们共享同一文件偏移量）。

接着，一般我们会调用exec执行另一个程序，此时会用全新的程序替换子进程的正文，数据，堆和栈等。此时保存文件描述符的变量当然也不存在了，我们就无法关闭无用的文件描述符了。所以通常我们会fork子进程后在子进程中直接执行close关掉无用的文件描述符，然后再执行exec。

但是在复杂系统中，有时我们fork子进程时已经不知道打开了多少个文件描述符（包括socket句柄等），这此时进行逐一清理确实有很大难度。我们期望的是能在fork子进程前打开某个文件句柄时就指定好：“这个句柄我在fork子进程后执行exec时就关闭”。其实时有这样的方法的：即所谓的 close-on-exec。

最近好好看了一下open函数，其中flags参数可以传入O_CLOEXEC标记 [注意：linux 2.6.23才开始支持此标记]

这样就可以一步实现上面的提到的close-on-exec的效果。

> https://blog.csdn.net/chrisniu1984/article/details/7050663