---
layout: post
title:  "http2 笔记1"
date:   2021-09-26 00:00:00 +0800
categories: cs network
tag: http2
---

## header压缩

我们平常听到的GZIP压缩仅仅是针对HTTP请求的Body部分进行的，这只能算是半压缩。对于很多API服务来说，返回的内容体其实并不大，这个时候请求头就占据了大部分流量。HTTP2将魔爪伸到了HTTP头部，这回是彻底的对整个请求都进行压缩了。

HTTP2的头压缩原理完全不同于HTTP1.1，它将常用的HEADER键值对映射到一个静态表里面的索引值，于是很多头部的键值对使用一个位置索引来表示就可以了。这样便大大节省了头部消息的长度。对于那些不常用的自定义的头部会使用一个动态表来维护，具体原理有一定复杂度，这里就不再啰嗦了。

## server push

Server Push不同于Websocket，Server Push一般是指服务器主动向客户端推送数据，这是一种单向的主动推送，而WebSocket是双向的，这两种技术不是竞争关系。Server Push可以用在服务器主动向客户端推送静态资源，比如浏览器请求index.html时，服务器除了返回网页内容外，还会将index.html页面里面的各种css和js一起推送到浏览器缓存起来，当浏览器分析了网页内容发现静态资源时，不需要再去服务器请求一次，它只需要从缓存里直接拿就可以了。不过现代的网站的静态资源大多都是CDN架构的，静态资源都在第三方服务器，Server Push在这方面作用并不大。Server Push还可以用在推送通知消息，比如谁关注了你，谁给你点了赞等，这个可以替代古老的Comet技术和近几年Google推广的SPDY协议，它需要服务器维持当前的TCP通道不关闭，需要持续占用服务器资源。

## pipeline

Pipeline是指后一个HTTP请求无需等待前一个HTTP请求返回结果就可以提前发起。HTTP1.1也有Pipeline支持，但是有所不足，并行的还不够彻底。它可以提前发起请求，但是却限定了返回结果必须和收到请求的顺序保持一致而不能乱序。如果第一个请求服务器处理慢了，那么后续的返回结果客户端无法立即收到，而必须等到第一个结果全部返回了才行。HTTP2则解决了这个问题，它支持乱序返回，甚至不同请求的返回结果的分块【HTTP Chunk】也可以交叉返回而不会混乱，这种技术称之为Multiplexing【多路复用】。


## 多路复用

HTTP2协议是二进制协议，不同于HTTP1.1的文本协议。文本协议是以特殊的符号结尾【换行回车符】来分割消息的，而二进制协议是通过字节长度来分割消息。二进制协议虽然直观性不如文本协议，但是在实现的时候要简单直接一些。

HTTP2为支持多路复用，在同一条TCP通道上支持发送多个资源／请求，将每条资源／请求定义为一个Stream【流】，同一个TCP通道可以传输多个Stream。同时为了支持多个资源的并行交错发送，将Stream再次分割为多个Frame【帧】，帧与帧之间可以交错发送。接收端通过流ID将这些帧组装起来，通一个流ID的帧属于同一个资源／请求。因为TCP协议已经可以保证消息包是有序的，所以接收端不必担心乱序问题。

以下内容参考：
> https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/

流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；
消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。
帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等

HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。

在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2 中：

同域名下所有通信都在单个连接上完成。
单个连接可以承载任意数量的双向数据流。
数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。
这一特性，使性能有了极大提升：

同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗。
并行交错地发送多个请求，请求之间互不影响。
并行交错地发送多个响应，响应之间互不干扰。
在 HTTP/2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。

## 参考

> https://zhuanlan.zhihu.com/p/33769711